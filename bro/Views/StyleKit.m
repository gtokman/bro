//
//  StyleKit.m
//  yo
//
//  Created by Gary Tokman on 5/6/17.
//  Copyright Â© 2017 Gary Tokman. All rights reserved.
//
//  Generated by PaintCode Plugin for Sketch
//  http://www.paintcodeapp.com/sketch
//

@import UIKit;
#import "StyleKit.h"



@implementation StyleKit


#pragma mark - Canvas Drawings

//! Page 1

+ (void)drawSearchButton {
  [StyleKit drawSearchButtonWithFrame:CGRectMake(0, 0, 104, 104) resizing:StyleKitResizingBehaviorAspectFit];
}
+ (void)drawSearchButtonWithFrame:(CGRect)targetFrame resizing:(StyleKitResizingBehavior)resizing {
  //! General Declarations
  CGContextRef context = UIGraphicsGetCurrentContext();
  CGAffineTransform baseTransform = CGAffineTransformInvert(CGContextGetUserSpaceToDeviceSpaceTransform(context));
  
  //! Resize to Target Frame
  CGContextSaveGState(context);
  CGRect resizedFrame = StyleKitResizingBehaviorApply(resizing, CGRectMake(0, 0, 104, 104), targetFrame);
  CGContextTranslateCTM(context, resizedFrame.origin.x, resizedFrame.origin.y);
  CGContextScaleCTM(context, resizedFrame.size.width / 104, resizedFrame.size.height / 104);
  
  //! searchBg
  UIBezierPath *searchBg = [UIBezierPath bezierPath];
  [searchBg moveToPoint:CGPointMake(0.39, 100)];
  [searchBg addCurveToPoint:CGPointMake(0, 91.74) controlPoint1:CGPointMake(0.13, 97.28) controlPoint2:CGPointMake(0, 94.53)];
  [searchBg addCurveToPoint:CGPointMake(98.04, 0) controlPoint1:CGPointMake(0, 41.07) controlPoint2:CGPointMake(43.89, 0)];
  [searchBg addCurveToPoint:CGPointMake(100, 0.02) controlPoint1:CGPointMake(98.69, 0) controlPoint2:CGPointMake(99.35, 0.01)];
  [searchBg addLineToPoint:CGPointMake(100, 100)];
  [searchBg addLineToPoint:CGPointMake(0.39, 100)];
  [searchBg closePath];
  [searchBg moveToPoint:CGPointMake(0.39, 100)];
  CGContextSaveGState(context);
  CGContextTranslateCTM(context, 4, 4);
  searchBg.usesEvenOddFillRule = YES;
  CGContextSaveGState(context);
  CGContextBeginPath(context);
  CGContextAddPath(context, searchBg.CGPath);
  CGContextAddRect(context, CGRectInset(searchBg.bounds, -14, -14));
  CGContextEOClip(context);
  CGContextTranslateCTM(context, -125, 0);
  {
    CGPoint baseZero = CGPointApplyAffineTransform(CGContextConvertPointToDeviceSpace(context, CGPointZero), baseTransform);
    CGPoint baseOne = CGPointApplyAffineTransform(CGContextConvertPointToDeviceSpace(context, CGPointMake(1, 1)), baseTransform);
    CGPoint baseOffset = CGPointApplyAffineTransform(CGContextConvertPointToDeviceSpace(context, CGPointMake(125, 0)), baseTransform);
    CGSize shadowOffset = CGSizeMake(baseOffset.x - baseZero.x, baseOffset.y - baseZero.y);
    CGFloat shadowBlur = 4 * MIN(baseOne.x - baseZero.x, baseOne.y - baseZero.y);
    CGContextSetShadowWithColor(context, shadowOffset, shadowBlur, [UIColor colorWithWhite:0 alpha:0.5].CGColor);
  }
  CGContextBeginTransparencyLayer(context, nil);
  {
    [UIColor.blackColor setFill];
    [searchBg fill];
    CGContextSaveGState(context);
    searchBg.lineWidth = 2;
    [UIColor.blackColor setStroke];
    [searchBg stroke];
    CGContextRestoreGState(context);
  }
  CGContextEndTransparencyLayer(context);
  CGContextRestoreGState(context);
  searchBg.usesEvenOddFillRule = YES;
  [[UIColor colorWithWhite:0.847 alpha:1] setFill];
  [searchBg fill];
  CGContextRestoreGState(context);
  //! add text
  UIBezierPath *addText = [UIBezierPath bezierPath];
  [addText moveToPoint:CGPointMake(16.18, 11.82)];
  [addText addLineToPoint:CGPointMake(28, 11.82)];
  [addText addLineToPoint:CGPointMake(28, 16.18)];
  [addText addLineToPoint:CGPointMake(16.18, 16.18)];
  [addText addLineToPoint:CGPointMake(16.18, 28)];
  [addText addLineToPoint:CGPointMake(11.82, 28)];
  [addText addLineToPoint:CGPointMake(11.82, 16.18)];
  [addText addLineToPoint:CGPointMake(0, 16.18)];
  [addText addLineToPoint:CGPointMake(0, 11.82)];
  [addText addLineToPoint:CGPointMake(11.82, 11.82)];
  [addText addLineToPoint:CGPointMake(11.82, 0)];
  [addText addLineToPoint:CGPointMake(16.18, 0)];
  [addText addLineToPoint:CGPointMake(16.18, 11.82)];
  [addText closePath];
  [addText moveToPoint:CGPointMake(16.18, 11.82)];
  CGContextSaveGState(context);
  CGContextTranslateCTM(context, 50, 51);
  addText.usesEvenOddFillRule = YES;
  [UIColor.whiteColor setFill];
  [addText fill];
  CGContextRestoreGState(context);
  
  CGContextRestoreGState(context);
}

+ (void)drawNotificationButton {
  [StyleKit drawNotificationButtonWithFrame:CGRectMake(0, 0, 100, 100) resizing:StyleKitResizingBehaviorAspectFit];
}
+ (void)drawNotificationButtonWithFrame:(CGRect)targetFrame resizing:(StyleKitResizingBehavior)resizing {
  //! General Declarations
  CGContextRef context = UIGraphicsGetCurrentContext();
  CGAffineTransform baseTransform = CGAffineTransformInvert(CGContextGetUserSpaceToDeviceSpaceTransform(context));
  
  //! Resize to Target Frame
  CGContextSaveGState(context);
  CGRect resizedFrame = StyleKitResizingBehaviorApply(resizing, CGRectMake(0, 0, 100, 100), targetFrame);
  CGContextTranslateCTM(context, resizedFrame.origin.x, resizedFrame.origin.y);
  CGContextScaleCTM(context, resizedFrame.size.width / 100, resizedFrame.size.height / 100);
  
  //! notificationGroup
  {
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 10, 10);
    
    //! notificationBg
    UIBezierPath *notificationBg = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 80, 80)];
    CGContextSaveGState(context);
    CGContextSaveGState(context);
    CGContextBeginPath(context);
    CGContextAddPath(context, notificationBg.CGPath);
    CGContextAddRect(context, CGRectInset(notificationBg.bounds, -14, -14));
    CGContextEOClip(context);
    CGContextTranslateCTM(context, -105, 0);
    {
      CGPoint baseZero = CGPointApplyAffineTransform(CGContextConvertPointToDeviceSpace(context, CGPointZero), baseTransform);
      CGPoint baseOne = CGPointApplyAffineTransform(CGContextConvertPointToDeviceSpace(context, CGPointMake(1, 1)), baseTransform);
      CGPoint baseOffset = CGPointApplyAffineTransform(CGContextConvertPointToDeviceSpace(context, CGPointMake(105, 0)), baseTransform);
      CGSize shadowOffset = CGSizeMake(baseOffset.x - baseZero.x, baseOffset.y - baseZero.y);
      CGFloat shadowBlur = 4 * MIN(baseOne.x - baseZero.x, baseOne.y - baseZero.y);
      CGContextSetShadowWithColor(context, shadowOffset, shadowBlur, [UIColor colorWithWhite:0 alpha:0.5].CGColor);
    }
    CGContextBeginTransparencyLayer(context, nil);
    {
      [UIColor.blackColor setFill];
      [notificationBg fill];
      CGContextSaveGState(context);
      notificationBg.lineWidth = 2;
      [UIColor.blackColor setStroke];
      [notificationBg stroke];
      CGContextRestoreGState(context);
    }
    CGContextEndTransparencyLayer(context);
    CGContextRestoreGState(context);
    [[UIColor colorWithHue:0.993 saturation:0.687 brightness:0.788 alpha:1] setFill];
    [notificationBg fill];
    CGContextRestoreGState(context);
    
    //! notificationText
    NSMutableAttributedString *notificationText = [[NSMutableAttributedString alloc] initWithString:@"1"];
    [notificationText addAttribute:NSFontAttributeName value:[UIFont fontWithName:@"AvenirNext-Medium" size:17] range:NSMakeRange(0, notificationText.length)];
    [notificationText addAttribute:NSForegroundColorAttributeName value:UIColor.whiteColor range:NSMakeRange(0, notificationText.length)];
    CGContextSaveGState(context);
    [notificationText drawAtPoint:CGPointMake(35, 27)];
    CGContextRestoreGState(context);
    
    CGContextRestoreGState(context);
  }
  
  CGContextRestoreGState(context);
}


#pragma mark - Canvas Images

//! Page 1

+ (UIImage *)imageOfSearchButton {
  static UIImage * image = nil;
  if (image != nil)
    return image;
  
  UIGraphicsBeginImageContextWithOptions(CGSizeMake(104, 104), NO, 0);
  [StyleKit drawSearchButton];
  image = UIGraphicsGetImageFromCurrentImageContext();
  UIGraphicsEndImageContext();
  
  return image;
}

+ (UIImage *)imageOfNotificationButton {
  static UIImage * image = nil;
  if (image != nil)
    return image;
  
  UIGraphicsBeginImageContextWithOptions(CGSizeMake(100, 100), NO, 0);
  [StyleKit drawNotificationButton];
  image = UIGraphicsGetImageFromCurrentImageContext();
  UIGraphicsEndImageContext();
  
  return image;
}


#pragma mark - Resizing Behavior

CGRect StyleKitResizingBehaviorApply(StyleKitResizingBehavior behavior, CGRect rect, CGRect target) {
  if (CGRectEqualToRect(rect, target) || CGRectEqualToRect(target, CGRectZero)) {
    return rect;
  }
  
  CGSize scales = CGSizeZero;
  scales.width = ABS(target.size.width / rect.size.width);
  scales.height = ABS(target.size.height / rect.size.height);
  
  switch (behavior) {
    case StyleKitResizingBehaviorAspectFit: {
      scales.width = MIN(scales.width, scales.height);
      scales.height = scales.width;
      break;
    }
    case StyleKitResizingBehaviorAspectFill: {
      scales.width = MAX(scales.width, scales.height);
      scales.height = scales.width;
      break;
    }
    case StyleKitResizingBehaviorStretch:
      break;
    
    case StyleKitResizingBehaviorCenter: {
      scales.width = 1;
      scales.height = 1;
      break;
    }
  }
  
  CGRect result = CGRectStandardize(rect);
  result.size.width *= scales.width;
  result.size.height *= scales.height;
  result.origin.x = target.origin.x + (target.size.width - result.size.width) / 2;
  result.origin.y = target.origin.y + (target.size.height - result.size.height) / 2;
  return result;
}


@end
